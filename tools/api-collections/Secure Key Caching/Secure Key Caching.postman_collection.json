{
	"info": {
		"_postman_id": "c50d2243-0c1c-4da1-b10b-9aa2891cf847",
		"name": "Secure Key Caching",
		"description": "Key Protection is implemented by the SKC Client -- a set of libraries - which must be linked with a\ntenant workload, like Nginx, deployed in a CSP environment and the Key Broker Service (KBS)\ndeployed in the tenant's enterprise environment. The SKC Client retrieves the keys needed by the\nworkload from KBS after proving that the key can be protected in an SGX enclave.",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
	},
	"item": [
		{
			"name": "Authorization",
			"item": [
				{
					"name": "createKbsToken",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.environment.set(\"bearerTokenKbs\", pm.response.text());"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Accept",
								"type": "text",
								"value": "application/jwt"
							},
							{
								"key": "Content-Type",
								"type": "text",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\r\n    \"username\": \"{{kbsUser}}\",\r\n    \"password\": \"{{kbsPass}}\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "https://{{aas}}:{{aasPort}}/aas/v1/token",
							"protocol": "https",
							"host": [
								"{{aas}}"
							],
							"port": "{{aasPort}}",
							"path": [
								"aas",
								"v1",
								"token"
							]
						},
						"description": "Creates a new bearer token that can be used in the Authorization header for other API requests. Bearer token Authorization is not required when requesting token for Authservice admin user. Authservice admin user bearer token should be provided in Authorization header when requesting bearer token for other users."
					},
					"response": [
						{
							"name": "Success",
							"originalRequest": {
								"method": "POST",
								"header": [
									{
										"key": "Accept",
										"value": "application/jwt",
										"type": "text"
									},
									{
										"key": "Content-Transfer-Encoding",
										"value": "application/json",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"username\": \"{{kbsUser}}\",\r\n    \"password\": \"{{kbsPass}}\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "https://{{aas}}:{{aasPort}}/aas/v1/token",
									"protocol": "https",
									"host": [
										"{{aas}}"
									],
									"port": "{{aasPort}}",
									"path": [
										"aas",
										"v1",
										"token"
									]
								}
							},
							"status": "OK",
							"code": 200,
							"_postman_previewlanguage": "jwt",
							"header": [
								{
									"key": "Content-Type",
									"value": "application/jwt"
								},
								{
									"key": "Date",
									"value": "Wed, 09 Sep 2020 13:14:33 GMT"
								},
								{
									"key": "Content-Length",
									"value": "843"
								}
							],
							"cookie": [],
							"body": "eyJhbGciOiJSUzM4NCIsImtpZCI6ImExMGFkYzJmNjA0OTg3NTRlYzExZjExNGQ0MDE3ZDI5ZDBjZmFiOWUiLCJ0eXAiOiJKV1QifQ.eyJyb2xlcyI6W3sic2VydmljZSI6IktNUyIsIm5hbWUiOiJLZXlDUlVEIn1dLCJwZXJtaXNzaW9ucyI6W3sic2VydmljZSI6IktNUyIsInJ1bGVzIjpbIio6KjoqIl19XSwiZXhwIjoxNTk5ODMwMDczLCJpYXQiOjE1OTk2NTcyNDMsImlzcyI6IkFBUyBKV1QgSXNzdWVyIiwic3ViIjoiRVR1c2VyIn0.hNOT_2JXJ0x9xx9XUULLYtDQLFn_Z8FeyXC85_EJ5Ha5Z0yTSz_noD_c_EHE-RZYzYcncCa_0JKboQb7YuU7tO4zQEF4OsxQkHkaIvgNoxChRskY4UDSfQgJImM9YGFWF3iLAavlJPJ0K7IorCFSYajABi1try4XND0tDDo7ah8GPszLtFwpKLCb9-_C6r-_JlbNUGYy_P9gq4IgPaC7lisr46id-sCBgNd-a8Z6Pf55mcPcJVqWIay7EWirSF9qo3cZLtUJ_aHs-38z1qZXJpJklD7AVhPR-MQdwiyturDe57wUC5-XrF2UKiZ4sWSe3YNcVKrwTNiXk0FC2WC5mNOoFV7Rr294zLyrXeF_xThtViqdReT5C7SWuAvng37y52nPUL1S4tBbsH7zqYl1o8hityZAlaYVGb_0dw1eklUXkYfW-KzKcfJRt2PJ9fVE-bkBFkWPyoJv10Gt7eiufxIlJBM8bo1itPaxboOUH4BCZfXlkwICOx5T0W6CbtYo"
						}
					]
				},
				{
					"name": "createEaToken",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.environment.set(\"bearerTokenEa\", pm.response.text());"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Accept",
								"type": "text",
								"value": "application/jwt"
							},
							{
								"key": "Content-Type",
								"type": "text",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\r\n    \"username\": \"{{eaUser}}\",\r\n    \"password\": \"{{eaPass}}\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "https://{{aas}}:{{aasPort}}/aas/v1/token",
							"protocol": "https",
							"host": [
								"{{aas}}"
							],
							"port": "{{aasPort}}",
							"path": [
								"aas",
								"v1",
								"token"
							]
						},
						"description": "Creates a new bearer token that can be used in the Authorization header for other API requests. Bearer token Authorization is not required when requesting token for Authservice admin user. Authservice admin user bearer token should be provided in Authorization header when requesting bearer token for other users."
					},
					"response": [
						{
							"name": "Success",
							"originalRequest": {
								"method": "POST",
								"header": [
									{
										"key": "Accept",
										"type": "text",
										"value": "application/jwt"
									},
									{
										"key": "Content-Type",
										"type": "text",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"username\": \"{{eaUser}}\",\r\n    \"password\": \"{{eaPass}}\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "https://{{aas}}:{{aasPort}}/aas/v1/token",
									"protocol": "https",
									"host": [
										"{{aas}}"
									],
									"port": "{{aasPort}}",
									"path": [
										"aas",
										"v1",
										"token"
									]
								}
							},
							"status": "OK",
							"code": 200,
							"_postman_previewlanguage": "jwt",
							"header": [
								{
									"key": "Content-Type",
									"value": "application/jwt"
								},
								{
									"key": "Date",
									"value": "Thu, 19 Nov 2020 06:27:47 GMT"
								},
								{
									"key": "Content-Length",
									"value": "843"
								}
							],
							"cookie": [],
							"body": "eyJhbGciOiJSUzM4NCIsImtpZCI6IjVmMzMzMjQxZDhmNWUxMTY0OTY5MTYxOGUyNzg2NDFmNzNkMGQyNTYiLCJ0eXAiOiJKV1QifQ.eyJyb2xlcyI6W3sic2VydmljZSI6IktCUyIsIm5hbWUiOiJLZXlDUlVEIn1dLCJwZXJtaXNzaW9ucyI6W3sic2VydmljZSI6IktCUyIsInJ1bGVzIjpbIio6KjoqIl19XSwiZXhwIjoxNjA1OTQwMDY3LCJpYXQiOjE2MDU3NjcyMzcsImlzcyI6IkFBUyBKV1QgSXNzdWVyIiwic3ViIjoiRUFkbWluIn0.S5RPoX_6z9u4mHLwxqiRUxvn6q6gKgGUf5qeBc6NsP3a4aZUGDKUnGbyIasWlRpeB6LbUX-XtU6XQ2HSUDt5Fg2bvtXDJE-rs_7AsSDWDrIhuEy4IVF-IB2N3VJjn1o9GSqC8m8AZE3pQ6006R2cVst9ma3xhC4JsQIsIHvzM9I4U1Bm8LTN4CdjjFmK9h7s6_WvF8VPSSaL2rF2iCjey06Rq5gTu6QdEDCOsLTREaRPN5308_8zecJNOkxS_J6BuAFbL15fuvpA07nyzmxNJ8DepWvuH0-GmEoR6ezJHQ54C6zWNVT6uIedFKlKkUQq4jnanSMaGCBJdD6oJZIcHPvkv7Rin_vaIzmEh1_qsBvOd0-3FVJKPUn2uW0NeLB-faOXKmrlMszhTGuOGmkyEAIaf-fo69hXDRp5cN6wdMXjkqCR1GCOkZQZsCFFt9cBJvVRCJt77sq4ty8rC_gtplSIWXF5Db1sZ3DcjOapGyQoksFm2lq0j1Dtwjj1-smo"
						}
					]
				}
			],
			"description": "To make an API request to an Intel® SecL-DC service, an authentication\r\ntoken is now required. API requests must now include an Authorization\r\nheader with an appropriate token:\r\n\r\n```\r\nAuthorization: Bearer <token>\r\n```\r\n\r\nThe token is issued by the AAS and will expire after a set amount of time.\r\nThis token may be used with any Intel® SecL-DC service, and will carry the\r\nappropriate permissions for the role(s) assigned to the account the token was\r\ngenerated for.",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				}
			]
		},
		{
			"name": "Verify Services",
			"item": [],
			"description": "The command-line option can be used to confirm that all services are up and running before proceeding to the actual use case demonstration.\n\nVerify KBS:\n\n```\nkbs status\n```\n\nVerify SQVS:\n\n```\nsqvs status\n```\n\nVerify SCS:\n\n```\nscs status\n```",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				}
			]
		},
		{
			"name": "Extracting SGX Enclave values for Key Transfer Policy",
			"item": [],
			"description": "Values that are specific to the enclave such as sgx_enclave_issuer_anyof, sgx_enclave_measurement_anyof and sgx_enclave_issuer_product_id_anyof can be retrived using sgx_sign utility that is available as part of Intel SGX SDK.\r\n\r\nRun sgx_sign utility on the signed enclave (This command should be run on the build system).\r\n\r\n```\r\n/opt/intel/sgxsdk/bin/x64/sgx_sign dump -enclave <path to the signed enclave> -dumpfile info.txt\r\n```\r\n\r\nFor sgx_enclave_issuer_anyof, in info.txt, search for \"mrsigner->value\" . E.g mrsigner->value :\r\n\r\n```\r\nmrsigner->value: \"0x83 0xd7 0x19 0xe7 0x7d 0xea 0xca 0x14 0x70 0xf6 0xba 0xf6 0x2a 0x4d 0x77 0x43 0x03 0xc8 0x99 0xdb 0x69 0x02 0x0f 0x9c 0x70 0xee 0x1d 0xfc 0x08 0xc7 0xce 0x9e\"\r\n```\r\n\r\nRemove the whitespace and 0x characters from the above string and add it to the policy file. E.g :\r\n\r\n```\r\n\"sgx_enclave_issuer_anyof\":[\"83d719e77deaca1470f6baf62a4d774303c899db69020f9c70ee1dfc08c7ce9e\"]\r\n```\r\n\r\nFor sgx_enclave_measurement_anyof, in info.txt, search for metadata->enclave_css.body.enclave_hash.m . E.g metadata->enclave_css.body.enclave_hash.m :\r\n\r\n```\r\nmetadata->enclave_css.body.enclave_hash.m:\r\n0xad 0x46 0x74 0x9e 0xd4 0x1e 0xba 0xa2 0x32 0x72 0x52 0x04 0x1e 0xe7 0x46 0xd3\r\n0x79 0x1a 0x9f 0x24 0x31 0x83 0x0f 0xee 0x08 0x83 0xf7 0x99 0x3c 0xaf 0x31 0x6a\r\n```\r\n\r\nRemove the whitespace and 0x characters from the above string and add it to the policy file. E.g :\r\n\r\n```\r\n\"sgx_enclave_measurement_anyof\":[\"ad46749ed41ebaa2327252041ee746d3791a9f2431830fee0883f7993caf316a\"]\r\n```"
		},
		{
			"name": "Creating RSA Keys in Key Broker Service",
			"item": [
				{
					"name": "keyTransferPolicy",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.environment.set(\"keyTransferPolicyId\", pm.response.json().id)"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"description": "Enter your bearer token in the format **Bearer &lt;token&gt;**",
								"key": "Authorization",
								"value": "Bearer {{bearerTokenEa}}"
							},
							{
								"description": "(Required) Accept header",
								"key": "Accept",
								"value": "application/json"
							},
							{
								"key": "Content-Type",
								"value": "application/json",
								"description": "(Required) Content-Type header"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"sgx_enclave_issuer_anyof\": [\n        \"cd171c56941c6ce49690b455f691d9c8a04c2e43e0a4d30f752fa5285c7ee57f\"\n    ],\n    \"sgx_enclave_issuer_product_id_anyof\": [\n        0\n    ],\n    \"sgx_enclave_issuer_extended_product_id_anyof\": [\n        \"00000000000000000000000000000000\"\n    ],\n    \"sgx_enclave_measurement_anyof\": [\n        \"7df0b7e815bd4b4af41239038d04a740daccf0beb412a2056c8d900b45b621fd\"\n    ],\n    \"sgx_config_id_svn\": 0,\n    \"sgx_enclave_svn_minimum\": 1,\n    \"sgx_config_id_anyof\": [\n        \"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"\n    ],\n    \"tls_client_certificate_issuer_cn_anyof\": [\n        \"CMSCA\",\n        \"CMS TLS Client CA\"\n    ],\n    \"client_permissions_allof\": [\n        \"nginx\",\n        \"USA\"\n    ],\n    \"attestation_type_anyof\": [\n        \"SGX\"\n    ],\n    \"sgx_enforce_tcb_up_to_date\": false\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "https://{{kbs}}:{{kbsPort}}/v1/key-transfer-policies",
							"protocol": "https",
							"host": [
								"{{kbs}}"
							],
							"port": "{{kbsPort}}",
							"path": [
								"v1",
								"key-transfer-policies"
							]
						},
						"description": "Creates a key transfer policy.\n\nThe serialized KeyTransferPolicyAttributes Go struct object represents the content of the request body.\n\n | Attribute                                    | Description |\n |----------------------------------------------|-------------|\n | sgx_enclave_issuer_anyof                     | Array of allowed common names of SGX enclave’s code signing certificate. This is mandatory. The same issuer must be added as a trusted certificate in key server configuration settings. |\n | sgx_enclave_issuer_product_id_anyof          | Array of (16-bit value) (ISVPRODID). This is mandatory. This is like a qualifier for the issuer so same issuer (code signing) key can sign separate products. |\n | sgx_enclave_issuer_extended_product_id_anyof | Array of (16-byte value) (ISVPRODID). This is like a qualifier for the issuer so same issuer key can sign separate products, it's like product id but simply bigger (starts in Coffee Lake). |\n | sgx_enclave_measurement_anyof                | Array of enclave measurements that are allowed to retrieve the key (MRENCLAVE). Expect client to have one of these measurements in the SGX quote (this supports use case of providing key only to an SGX enclave that will enforce the key usage policy locally). |\n | sgx_config_id_svn                            | Integer. |\n | sgx_enclave_svn_minimum                      | Minimum version number required. |\n | sgx_config_id_anyof                          | Array of config id measurements that are allowed to retrieve the key. Required value for the enclave to have when it launched. for loading e.g. Java applets into enclavized JVM, so that enclave measurement is JVM measurement, and when it launches it's configured with this id, so when it loads applet it can measure it and compare to config id in register, and refuse to load applet if wrong (starts in Coffee Lake). |\n | tls_client_certificate_issuer_cn_anyof       | Array of Common Name to expect on client certificate's issuer field. Expect client certificate to have any one of these issuers. |\n | tls_client_certificate_san_anyof             | Array of Subject Alternative Name to expect in client certificate's extensions. Expect client certificate to have any of these names. |\n | tls_client_certificate_san_allof             | Array of Subject Alternative Name to expect in client certificate's extensions. Expect client certificate to have all of these names. |\n | attestation_type_anyof                       | Array of Attestation Type identifiers that client must support to get the key expect client to advertise these with the key request e.g. \"SGX\", \"KPT2\" (note that if key server needs to restrict technologies, then it should list only the ones that can receive the key). |\n | sgx_enforce_tcb_up_to_date                   | Boolean. |\n"
					},
					"response": [
						{
							"name": "Success",
							"originalRequest": {
								"method": "POST",
								"header": [
									{
										"description": "Enter your bearer token in the format **Bearer &lt;token&gt;**",
										"key": "Authorization",
										"value": "Bearer {{bearerTokenEa}}"
									},
									{
										"description": "(Required) Accept header",
										"key": "Accept",
										"value": "application/json"
									},
									{
										"key": "Content-Type",
										"value": "application/json",
										"description": "(Required) Content-Type header"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"sgx_enclave_issuer_anyof\": [\n        \"cd171c56941c6ce49690b455f691d9c8a04c2e43e0a4d30f752fa5285c7ee57f\"\n    ],\n    \"sgx_enclave_issuer_product_id_anyof\": [\n        0\n    ],\n    \"sgx_enclave_issuer_extended_product_id_anyof\": [\n        \"00000000000000000000000000000000\"\n    ],\n    \"sgx_enclave_measurement_anyof\": [\n        \"7df0b7e815bd4b4af41239038d04a740daccf0beb412a2056c8d900b45b621fd\"\n    ],\n    \"sgx_config_id_svn\": 0,\n    \"sgx_enclave_svn_minimum\": 1,\n    \"sgx_config_id_anyof\": [\n        \"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"\n    ],\n    \"tls_client_certificate_issuer_cn_anyof\": [\n        \"CMSCA\",\n        \"CMS TLS Client CA\"\n    ],\n    \"client_permissions_allof\": [\n        \"nginx\",\n        \"USA\"\n    ],\n    \"attestation_type_anyof\": [\n        \"SGX\"\n    ],\n    \"sgx_enforce_tcb_up_to_date\": false\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "https://{{kbs}}:{{kbsPort}}/v1/key-transfer-policies",
									"protocol": "https",
									"host": [
										"{{kbs}}"
									],
									"port": "{{kbsPort}}",
									"path": [
										"v1",
										"key-transfer-policies"
									]
								}
							},
							"status": "Created",
							"code": 201,
							"_postman_previewlanguage": "json",
							"header": [
								{
									"key": "Content-Type",
									"value": "application/json"
								},
								{
									"key": "Date",
									"value": "Mon, 09 Nov 2020 10:32:57 GMT"
								},
								{
									"key": "Content-Length",
									"value": "767"
								}
							],
							"cookie": [],
							"body": "{\n    \"id\": \"{{keyTransferPolicyId}}\",\n    \"created_at\": \"2020-11-09T10:32:57.962968825Z\",\n    \"sgx_enclave_issuer_anyof\": [\n        \"cd171c56941c6ce49690b455f691d9c8a04c2e43e0a4d30f752fa5285c7ee57f\"\n    ],\n    \"sgx_enclave_issuer_product_id_anyof\": [\n        0\n    ],\n    \"sgx_enclave_issuer_extended_product_id_anyof\": [\n        \"00000000000000000000000000000000\"\n    ],\n    \"sgx_enclave_measurement_anyof\": [\n        \"7df0b7e815bd4b4af41239038d04a740daccf0beb412a2056c8d900b45b621fd\"\n    ],\n    \"sgx_config_id_svn\": 0,\n    \"sgx_enclave_svn_minimum\": 1,\n    \"sgx_config_id_anyof\": [\n        \"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"\n    ],\n    \"tls_client_certificate_issuer_cn_anyof\": [\n        \"CMSCA\",\n        \"CMS TLS Client CA\"\n    ],\n    \"client_permissions_allof\": [\n        \"nginx\",\n        \"USA\"\n    ],\n    \"attestation_type_anyof\": [\n        \"SGX\"\n    ]\n}"
						}
					]
				},
				{
					"name": "createKey",
					"request": {
						"method": "POST",
						"header": [
							{
								"description": "Enter your bearer token in the format **Bearer &lt;token&gt;**",
								"key": "Authorization",
								"value": "Bearer {{bearerTokenEa}}"
							},
							{
								"description": "(Required) Accept header",
								"key": "Accept",
								"value": "application/json"
							},
							{
								"key": "Content-Type",
								"value": "application/json",
								"description": "(Required) Content-Type header"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"key_information\": {\n        \"algorithm\": \"RSA\",\n        \"key_length\": 3072,\n        \"key_string\": \"{{privateKey}}\"\n    },\n    \"transfer_policy_ID\": \"{{keyTransferPolicyId}}\"\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "https://{{kbs}}:{{kbsPort}}/v1/keys",
							"protocol": "https",
							"host": [
								"{{kbs}}"
							],
							"port": "{{kbsPort}}",
							"path": [
								"v1",
								"keys"
							]
						},
						"description": "Creates or Registers a key.\n\nThe serialized KeyRequest Go struct object represents the content of the request body.\n\n | Attribute          | Description |\n |--------------------|-------------|\n | key_information    | A json object having all the required information about a key. |\n | transfer_policy_id | Unique identifier of the transfer policy to apply to this key. |\n | label              | String to attach optionally a text description to the key, e.g. \"US Nginx key\". |\n | usage              | String to attach optionally a usage criteria for the key, e.g. \"Country:US,State:CA\". |\n\nThe serialized KeyInformation Go struct object represents the content of the key_information field.\n\n | Attribute   | Description |\n |-------------|-------------|\n | algorithm   | Encryption algorithm used to create or register key. Supported algorithms are AES, RSA and EC. |\n | key_length  | Key length used to create key. Supported key lengths are 128,192,256 bits for AES and 2048,3072,4096,7680,15360 bits for RSA. |\n | curve_type  | Elliptic curve used to create key. Supported curves are secp256r1, secp384r1 and secp521r1. |\n | key_string  | Base64 encoded private key to be registered. Supported only if key is created locally. |\n | kmip_key_id | Unique KMIP identifier of key to be registered. Supported only if key is created on KMIP server. |\n"
					},
					"response": [
						{
							"name": "Success",
							"originalRequest": {
								"method": "POST",
								"header": [
									{
										"description": "Enter your bearer token in the format **Bearer &lt;token&gt;**",
										"key": "Authorization",
										"value": "Bearer {{bearerTokenEa}}"
									},
									{
										"description": "(Required) Accept header",
										"key": "Accept",
										"value": "application/json"
									},
									{
										"key": "Content-Type",
										"value": "application/json",
										"description": "(Required) Content-Type header"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"key_information\": {\n        \"algorithm\": \"RSA\",\n        \"key_length\": 3072,\n        \"key_string\": \"{{privateKey}}\"\n    },\n    \"transfer_policy_ID\": \"{{keyTransferPolicyId}}\"\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "https://{{kbs}}:{{kbsPort}}/v1/keys",
									"protocol": "https",
									"host": [
										"{{kbs}}"
									],
									"port": "{{kbsPort}}",
									"path": [
										"v1",
										"keys"
									]
								}
							},
							"status": "Created",
							"code": 201,
							"_postman_previewlanguage": "json",
							"header": [
								{
									"key": "Content-Type",
									"value": "application/json"
								},
								{
									"key": "Date",
									"value": "Mon, 09 Nov 2020 10:46:23 GMT"
								},
								{
									"key": "Content-Length",
									"value": "289"
								}
							],
							"cookie": [],
							"body": "{\n    \"key_information\": {\n        \"id\": \"{{keyId}}\",\n        \"algorithm\": \"RSA\",\n        \"key_length\": 3072\n    },\n    \"transfer_policy_id\": \"{{keyTransferPolicyId}}\",\n    \"transfer_link\": \"https://{{kbs}}:{{kbsPort}}/v1/keys/1403a86e-e75e-451e-a481-c12cbfe3bd21/transfer\",\n    \"created_at\": \"2020-11-09T10:46:23.354730925Z\"\n}"
						}
					]
				},
				{
					"name": "createKeyUsingKMIPId",
					"request": {
						"method": "POST",
						"header": [
							{
								"description": "Enter your bearer token in the format **Bearer &lt;token&gt;**",
								"key": "Authorization",
								"value": "Bearer {{bearerTokenEa}}"
							},
							{
								"description": "(Required) Accept header",
								"key": "Accept",
								"value": "application/json"
							},
							{
								"description": "(Required) Content-Type header",
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"key_information\": {\n        \"algorithm\": \"RSA\",\n        \"key_length\": 3072,\n        \"kmip_key_id\": \"{{kmipKeyId}}\"\n    },\n    \"transfer_policy_ID\": \"{{keyTransferPolicyId}}\"\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "https://{{kbs}}:{{kbsPort}}/v1/keys",
							"protocol": "https",
							"host": [
								"{{kbs}}"
							],
							"port": "{{kbsPort}}",
							"path": [
								"v1",
								"keys"
							]
						},
						"description": "Creates or Registers a key.\n\nThe serialized KeyRequest Go struct object represents the content of the request body.\n\n | Attribute          | Description |\n |--------------------|-------------|\n | key_information    | A json object having all the required information about a key. |\n | transfer_policy_id | Unique identifier of the transfer policy to apply to this key. |\n | label              | String to attach optionally a text description to the key, e.g. \"US Nginx key\". |\n | usage              | String to attach optionally a usage criteria for the key, e.g. \"Country:US,State:CA\". |\n\nThe serialized KeyInformation Go struct object represents the content of the key_information field.\n\n | Attribute   | Description |\n |-------------|-------------|\n | algorithm   | Encryption algorithm used to create or register key. Supported algorithms are AES, RSA and EC. |\n | key_length  | Key length used to create key. Supported key lengths are 128,192,256 bits for AES and 2048,3072,4096,7680,15360 bits for RSA. |\n | curve_type  | Elliptic curve used to create key. Supported curves are secp256r1, secp384r1 and secp521r1. |\n | key_string  | Base64 encoded private key to be registered. Supported only if key is created locally. |\n | kmip_key_id | Unique KMIP identifier of key to be registered. Supported only if key is created on KMIP server. |\n"
					},
					"response": [
						{
							"name": "Success",
							"originalRequest": {
								"method": "POST",
								"header": [
									{
										"description": "Enter your bearer token in the format **Bearer &lt;token&gt;**",
										"key": "Authorization",
										"value": "Bearer {{bearerTokenEa}}"
									},
									{
										"description": "(Required) Accept header",
										"key": "Accept",
										"value": "application/json"
									},
									{
										"description": "(Required) Content-Type header",
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"key_information\": {\n        \"algorithm\": \"RSA\",\n        \"key_length\": 3072,\n        \"kmip_key_id\": \"{{kmipKeyId}}\"\n    },\n    \"transfer_policy_ID\": \"{{keyTransferPolicyId}}\"\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "https://{{kbs}}:{{kbsPort}}/v1/keys",
									"protocol": "https",
									"host": [
										"{{kbs}}"
									],
									"port": "{{kbsPort}}",
									"path": [
										"v1",
										"keys"
									]
								}
							},
							"status": "Created",
							"code": 201,
							"_postman_previewlanguage": "json",
							"header": [
								{
									"key": "Content-Type",
									"value": "application/json"
								},
								{
									"key": "Date",
									"value": "Wed, 14 Apr 2021 07:30:39 GMT"
								},
								{
									"key": "Content-Length",
									"value": "324"
								}
							],
							"cookie": [],
							"body": "{\n    \"key_information\": {\n        \"id\": \"{{keyId}}\",\n        \"algorithm\": \"RSA\",\n\t\t\"key_length\": 3072,\n         \"kmip_key_id\": \"{{kmipKeyId}}\"\n    },\n    \"transfer_policy_id\": \"{{keyTransferPolicyId}}\",\n    \"transfer_link\": \"https://{{kbs}}:{{kbsPort}}/v1/keys/1403a86e-e75e-451e-a481-c12cbfe3bd21/transfer\",\n    \"created_at\": \"2020-11-09T10:46:23.354730925Z\"\n}"
						}
					]
				}
			],
			"description": "**Steps to run KMIP Server**\n\nNote: Below mentioned steps are provided as script (install_pykmip.sh and pykmip.service) as part of kbs_script folder which will install KMIP Server as daemon. Refer to ‘Install KMIP Server as daemon’ section.\n\n```\n1. Install python3 and vim-common\n   # dnf -y install python3-pip vim-common (RHEL 8.2)\n   # apt -y install python3-pip vim-common (UBUNTU 18.04) \n   ln -s /usr/bin/python3 /usr/bin/python  > /dev/null 2>&1\n   ln -s /usr/bin/pip3 /usr/bin/pip  > /dev/null 2>&1\n\n2. Install pykmip\n   # pip3 install pykmip==0.9.1\n\n3. In the /etc/ directory create pykmip and policies folders\n   mkdir -p /etc/pykmip/policies\n\n4. Configure pykmip server using server.conf\n   Update hostname in the server.conf\n\n5. Copy the following to /etc/pykmip/ from kbs_script folder available under binaries directory\n   create_certificates.py, run_server.py, server.conf\n\n6. Create certificates\n   > cd /etc/pykmip\n   > python3 create_certificates.py\n\n7. Kill running KMIP Server processes and wait for 10 seconds until all the KMIP Server processes are killed. \n   > ps -ef | grep run_server.py | grep -v grep | awk '{print $2}' | xargs kill\n\n8. Run pykmip server using run_server.py script\n   > python3 run_server.py &\n\n```\n\n**Install KMIP Server as daemon**\n\n```\n1. cd into /root/binaries/kbs_script folder \n\n2. Configure pykmip server using server.conf\n   Update hostname in the server.conf\n\n3. Run the install_pykmip.sh script and KMIP server will be installed as daemon process\n   ./install_pykmip.sh\n```\n\n**Create RSA key in PyKMIP and generate certificate**\n\nNOTE: This step is required only when PyKMIP script is used as a backend KMIP server.\n\n```\n1. Update Host IP in /root/binaries/kbs_script rsa_create.py script\n2. In the kbs_script folder, Run rsa_create.py script\n    > cd /root/binaries/kbs_script\n    > python3 rsa_create.py\n\nThis script will generate “Private Key ID” and “Server certificate”, which should be provided in the kbs.conf file for “KMIP_KEY_ID” and “SERVER_CERT”.\n```\n\n**Configuration Update to create Keys in KBS**\n    \n    cd into /root/binaries/kbs_script folder\n\t\n    **To register keys with KBS KMIP**\n    \n    Update the following variables in kbs.conf:\n    \n        KMIP_KEY_ID (Private key ID registered in KMIP server)\n        \n        SERVER_CERT (Server certificate for created private key)\n\t\t\n\t\tEnterprise system IP address where CMS, AAS and KBS services are deployed\n        \n\t\tPort of CMS, AAS and KBS services deployed on enterprise system\n    \n\t    AAS admin and Enterprise admin credentials\n        \nNOTE: If KMIP_KEY_ID is not provided then RSA key register will be done with keystring.\n\nUpdate sgx_enclave_measurement_anyof value in transfer_policy_request.json with enclave measurement value obtained using sgx_sign utility. Refer to \"Extracting SGX Enclave values for Key Transfer Policy\" section.\n\n**Create RSA Key**\n\n\tExecute the command\n\t\n\t./run.sh reg\n\nCopy the generated cert file to SGX Compute node where skc_library is deployed. Also make a note of the key id generated.\n\n```\nscp <cert path> root@<SGX Compute Node>:/root/\n```",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				}
			]
		},
		{
			"name": "Configuration for NGINX testing",
			"item": [],
			"description": "**Note:** Below mentioned OpenSSL and NGINX configuration updates are provided as patches (nginx.patch and openssl.patch) as part of skc_library deployment script. Patch can be applied with default nginx and openssl file. In case nginx/openssl contains any external changes then refer manual step.\n\n**Apply Patch for Ubuntu**\n\nExecute the command with nginx version - nginx 1.14.0 (Ubuntu 18.04) and openssl version- Openssl 1.1.1 (Ubuntu 18.04)\n    \n    patch -b /etc/nginx/nginx.conf < nginx_ubuntu.patch\n    patch -b /etc/ssl/openssl.cnf < openssl_ubuntu.patch\n\n**Apply Patch for Rhel**\n\nExecute the command with nginx version - nginx 1.14.1 (Rhel 8.2) and openssl version- Openssl 1.1.1g (Rhel 8.2)\n\n    patch -b /etc/nginx/nginx.conf < nginx.patch\n    patch -b /etc/pki/tls/openssl.cnf < openssl.patch\n\n**OpenSSL**\n\nFor UBUNTU in the /etc/ssl/openssl.cnf file, look for the below line:\n[ new_oids ]\n\nJust before the line [ new_oids ], add the below section:\n\nopenssl_conf = openssl_def\n\n[openssl_def]\nengines = engine_section\noid_section = new_oids\n\n[engine_section]\npkcs11 = pkcs11_section\n\n[pkcs11_section]\nengine_id = pkcs11\ndynamic_path =/usr/lib/x86_64-linux-gnu/engines-1.1/pkcs11.so\nMODULE_PATH =/opt/skc/lib/libpkcs11-api.so \ninit = 0\n\n\n\nFor RHEL update openssl configuration file /etc/pki/tls/openssl.cnf with below changes:\n\n[openssl_def]\nengines = engine_section\n\n[engine_section]\npkcs11 = pkcs11_section\n\n[pkcs11_section]\nengine_id = pkcs11\n\ndynamic_path =/usr/lib64/engines-1.1/pkcs11.so\n\nMODULE_PATH =/opt/skc/lib/libpkcs11-api.so\n\ninit = 0\n\n**Nginx**\n\nUpdate nginx configuration file /etc/nginx/nginx.conf with below changes:\n\nssl_engine pkcs11;\n\nUpdate the location of certificate with the loaction where it was copied into the skc_library machine. \n\nssl_certificate \"add absolute path of crt file\";\n\nUpdate the fields(token, object and pin-value) with the values given in keys.txt for the KeyID corresponding to the certificate.\n\nssl_certificate_key \"engine:pkcs11:pkcs11:token=KMS;object=RSAKEY;pin-value=1234\";\n\n**SKC Configuration**\n\n Create keys.txt in /root folder. This provides key preloading functionality in skc_library.\n\n  Any number of keys can be added in keys.txt. Each PKCS11 URL should contain different Key ID which need to be transferred from KBS along with respective object tag for each key id specified\n\n  Sample PKCS11 url is as below\n  \n  pkcs11:token=KMS;id=164b41ae-be61-4c7c-a027-4a2ab1e5e4c4;object=RSAKEY;type=private;pin-value=1234;\n  \n  Token, object and pin-value given in PKCS11 url entry in keys.txt should match with the one in nginx.conf.\n\n  The keyID should match the keyID of RSA key created in KBS. File location should match with preload_keys directive in pkcs11-apimodule.ini; \n\n  Sample /opt/skc/etc/pkcs11-apimodule.ini file for UBUNTU\n\t\n\t[core]\n\tpreload_keys=/root/keys.txt\n\tkeyagent_conf=/opt/skc/etc/key-agent.ini\n\tmode=SGX\n\tdebug=true\n\t\n\t[SW]\n\tmodule=/usr/lib/softhsm/libsofthsm2.so\n\t\n\t[SGX]\n\tmodule=/opt/intel/cryptoapitoolkit/lib/libp11sgx.so\n\nSample /opt/skc/etc/pkcs11-apimodule.ini file for RHEL\n\t\n\t[core]\n\tpreload_keys=/root/keys.txt\n\tkeyagent_conf=/opt/skc/etc/key-agent.ini\n\tmode=SGX\n\tdebug=true\n\t\n\t[SW]\n\tmodule=/usr/lib64/pkcs11/libsofthsm2.so\n\t\n\t[SGX]\n\tmodule=/opt/intel/cryptoapitoolkit/lib/libp11sgx.so\n\nNOTE: 'daemon off' should not be present in nginx.conf file.",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				}
			]
		},
		{
			"name": "KBS key-transfer flow",
			"item": [
				{
					"name": "sgxVerifyQuote",
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							},
							{
								"key": "Accept",
								"value": "application/json",
								"type": "text"
							},
							{
								"key": "Authorization",
								"value": "Bearer {{bearerTokenKbs}}",
								"description": "Enter your bearer token in the format **Bearer &lt;token&gt;**",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"quote\": \"<string>\",\n    \"userData\": \"<string>\"\n}"
						},
						"url": {
							"raw": "https://{{sqvs}}:{{sqvsPort}}/svs/v1/sgx_qv_verify_quote",
							"protocol": "https",
							"host": [
								"{{sqvs}}"
							],
							"port": "{{sqvsPort}}",
							"path": [
								"svs",
								"v1",
								"sgx_qv_verify_quote"
							]
						},
						"description": "Verifies the SGX ECDSA quote provided in the request body.\nQuote verifier requests SGX Quote Verification Service (SQVS) to verify quote.\nSQVS parses the quote, verifies all the parameters in the quote and returns the response.\n"
					},
					"response": [
						{
							"name": "Success",
							"originalRequest": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"name": "Content-Type",
										"value": "application/json",
										"type": "text"
									},
									{
										"key": "Accept",
										"value": "application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": "Bearer {{bearerTokenKbs}}",
										"description": "Enter your bearer token in the format **Bearer &lt;token&gt;**",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"quote\": \"AwACAAAAAAAFAAoAk5pyM/ecTKmUCg2zlX8GB3HHO7ubYF/PJVbCISbSSAYAAAAAAgIAAgIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAAAAAAAADnAAAAAAAAAD708T5CMYqlBj/XQN5SkwSIu/+GIzYcaGw4HETKqHk9AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADNFxxWlBxs5JaQtFX2kdnIoEwuQ+Ck0w91L6UoXH7lfwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABT9iwCApadupRBkF6TjjvN+79hY/cURtoFb0N+tQQyDwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA2BAAAJebwh/oA8bfeD/7labQe/F7QldB20tL5lSz75DMYrkqe03HqBfx9I8Ea7/k0eMW7A+L/y8qwL/kUtc5eNPX+o/jyVSxJEHZ7uLmoxVdtTBiQpSv5JR5M2qem33SYcVB9uycLbAd0iOrWpE2Hnm7q/qLAVj//UbB/+dThPvPvWFkAgIAAgIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFQAAAAAAAADnAAAAAAAAAGDYWvKL6NHECgjZiwCdX4rME4Sjhc9GCADkeHkdGpecAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACMT1d115ZQPpYTf3fGioKaAFasje1wFAsIGwlEkMV7/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAtUZdwWxK4I7b//LXQQxF/XgH8vIUXGer+OwNKaOBjKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAiSP8Nr+QcNR3EvCQ7pbDROOG2Th43bmKTtWLFCuYx1S8qvtzEro7hKxgUS68j7yfxe0/1su+xo7lR3jX94ntQSAAAAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8FAHAOAAAtLS0tLUJFR0lOIENFUlRJRklDQVRFLS0tLS0KTUlJRTlUQ0NCSnFnQXdJQkFnSVVlVERLVXZ5V2h4TmRsbWhFVXM1eGhSUEJUWlV3Q2dZSUtvWkl6ajBFQXdJd2NERWlNQ0FHQTFVRQpBd3daU1c1MFpXd2dVMGRZSUZCRFN5QlFiR0YwWm05eWJTQkRRVEVhTUJnR0ExVUVDZ3dSU1c1MFpXd2dRMjl5Y0c5eVlYUnBiMjR4CkZEQVNCZ05WQkFjTUMxTmhiblJoSUVOc1lYSmhNUXN3Q1FZRFZRUUlEQUpEUVRFTE1Ba0dBMVVFQmhNQ1ZWTXdIaGNOTWpFd01qRXkKTVRjeE16UTFXaGNOTWpnd01qRXlNVGN4TXpRMVdqQndNU0l3SUFZRFZRUUREQmxKYm5SbGJDQlRSMWdnVUVOTElFTmxjblJwWm1sagpZWFJsTVJvd0dBWURWUVFLREJGSmJuUmxiQ0JEYjNKd2IzSmhkR2x2YmpFVU1CSUdBMVVFQnd3TFUyRnVkR0VnUTJ4aGNtRXhDekFKCkJnTlZCQWdNQWtOQk1Rc3dDUVlEVlFRR0V3SlZVekJaTUJNR0J5cUdTTTQ5QWdFR0NDcUdTTTQ5QXdFSEEwSUFCT0NjNHdiRzI4SjkKcWNXUjg1Zzl6YmFWbXViemxnc2szbkZOZUhvVW5OR3lHOXFoU1BXdVg5clRLYk1hdFdBbi8xdXY2UzFOTmFPaDNxcmdyb0pIUnRxagpnZ01RTUlJREREQWZCZ05WSFNNRUdEQVdnQlJaSTlPblNxaGpWQzQ1Y0szZ0R3Y3JWeVFxdHpCdkJnTlZIUjhFYURCbU1HU2dZcUJnCmhsNW9kSFJ3Y3pvdkwzTmllQzVoY0drdWRISjFjM1JsWkhObGNuWnBZMlZ6TG1sdWRHVnNMbU52YlM5elozZ3ZZMlZ5ZEdsbWFXTmgKZEdsdmJpOTJNeTl3WTJ0amNtdy9ZMkU5Y0d4aGRHWnZjbTBtWlc1amIyUnBibWM5WkdWeU1CMEdBMVVkRGdRV0JCUjNIbkZYczJMcApPVmkwVWhwVk9qeGNnclF2VmpBT0JnTlZIUThCQWY4RUJBTUNCc0F3REFZRFZSMFRBUUgvQkFJd0FEQ0NBamtHQ1NxR1NJYjRUUUVOCkFRU0NBaW93Z2dJbU1CNEdDaXFHU0liNFRRRU5BUUVFRUtwVWpKSmk4Q0xoa0h3em15d1dnQWN3Z2dGakJnb3Foa2lHK0UwQkRRRUMKTUlJQlV6QVFCZ3NxaGtpRytFMEJEUUVDQVFJQkFqQVFCZ3NxaGtpRytFMEJEUUVDQWdJQkFqQVFCZ3NxaGtpRytFMEJEUUVDQXdJQgpBREFRQmdzcWhraUcrRTBCRFFFQ0JBSUJBREFRQmdzcWhraUcrRTBCRFFFQ0JRSUJBREFRQmdzcWhraUcrRTBCRFFFQ0JnSUJBREFRCkJnc3Foa2lHK0UwQkRRRUNCd0lCQURBUUJnc3Foa2lHK0UwQkRRRUNDQUlCQURBUUJnc3Foa2lHK0UwQkRRRUNDUUlCQURBUUJnc3EKaGtpRytFMEJEUUVDQ2dJQkFEQVFCZ3NxaGtpRytFMEJEUUVDQ3dJQkFEQVFCZ3NxaGtpRytFMEJEUUVDREFJQkFEQVFCZ3NxaGtpRworRTBCRFFFQ0RRSUJBREFRQmdzcWhraUcrRTBCRFFFQ0RnSUJBREFRQmdzcWhraUcrRTBCRFFFQ0R3SUJBREFRQmdzcWhraUcrRTBCCkRRRUNFQUlCQURBUUJnc3Foa2lHK0UwQkRRRUNFUUlCQ2pBZkJnc3Foa2lHK0UwQkRRRUNFZ1FRQWdJQUFBQUFBQUFBQUFBQUFBQUEKQURBUUJnb3Foa2lHK0UwQkRRRURCQUlBQURBVUJnb3Foa2lHK0UwQkRRRUVCQVlRWUdvQUFBQXdEd1lLS29aSWh2aE5BUTBCQlFvQgpBVEFlQmdvcWhraUcrRTBCRFFFR0JCQ2NTcUM0NW5KWWJuMXpHSEdVWFJoK01FUUdDaXFHU0liNFRRRU5BUWN3TmpBUUJnc3Foa2lHCitFMEJEUUVIQVFFQi96QVFCZ3NxaGtpRytFMEJEUUVIQWdFQkFEQVFCZ3NxaGtpRytFMEJEUUVIQXdFQi96QUtCZ2dxaGtqT1BRUUQKQWdOSkFEQkdBaUVBN3JXamVieTltZDNBWmk4bnJSR2NpdnRZYWZnOERObEVRUlhVQS9RQ0NJY0NJUUNxeGM0YjcveVczOFp2aytFSwpSQWY2aVJhdmNEbk1rcE9ZbmJ3TFJ4Q05OZz09Ci0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0tLS0tLUJFR0lOIENFUlRJRklDQVRFLS0tLS0KTUlJQ21qQ0NBa0NnQXdJQkFnSVVXU1BUcDBxb1kxUXVPWEN0NEE4SEsxY2tLcmN3Q2dZSUtvWkl6ajBFQXdJdwphREVhTUJnR0ExVUVBd3dSU1c1MFpXd2dVMGRZSUZKdmIzUWdRMEV4R2pBWUJnTlZCQW9NRVVsdWRHVnNJRU52CmNuQnZjbUYwYVc5dU1SUXdFZ1lEVlFRSERBdFRZVzUwWVNCRGJHRnlZVEVMTUFrR0ExVUVDQXdDUTBFeEN6QUoKQmdOVkJBWVRBbFZUTUI0WERURTVNVEF6TVRFeU16TTBOMW9YRFRNME1UQXpNVEV5TXpNME4xb3djREVpTUNBRwpBMVVFQXd3WlNXNTBaV3dnVTBkWUlGQkRTeUJRYkdGMFptOXliU0JEUVRFYU1CZ0dBMVVFQ2d3UlNXNTBaV3dnClEyOXljRzl5WVhScGIyNHhGREFTQmdOVkJBY01DMU5oYm5SaElFTnNZWEpoTVFzd0NRWURWUVFJREFKRFFURUwKTUFrR0ExVUVCaE1DVlZNd1dUQVRCZ2NxaGtqT1BRSUJCZ2dxaGtqT1BRTUJCd05DQUFRd3ArTGMrVFVCdGcxSAorVThKSXNNc2JqSGpDa1R0WGI4alBNNnIyZGh1OXpJYmxoRFo3SU5mcXQzSXg4WGNGS0Q4azBORVhya1o2NnFKClhhMUt6TElLbzRHL01JRzhNQjhHQTFVZEl3UVlNQmFBRk9ub1JGSlRObHhMR0pvUi9FTVlMS1hjSUlCSU1GWUcKQTFVZEh3UlBNRTB3UzZCSm9FZUdSV2gwZEhCek9pOHZjMko0TFdObGNuUnBabWxqWVhSbGN5NTBjblZ6ZEdWawpjMlZ5ZG1salpYTXVhVzUwWld3dVkyOXRMMGx1ZEdWc1UwZFlVbTl2ZEVOQkxtUmxjakFkQmdOVkhRNEVGZ1FVCldTUFRwMHFvWTFRdU9YQ3Q0QThISzFja0tyY3dEZ1lEVlIwUEFRSC9CQVFEQWdFR01CSUdBMVVkRXdFQi93UUkKTUFZQkFmOENBUUF3Q2dZSUtvWkl6ajBFQXdJRFNBQXdSUUloQUoxcStGVHorZ1V1VmZCUXVDZ0pzRnJMMlRUUwplMWFCWjUzTzUyVGpGaWU2QWlBcmlQYVJhaFVYOU9hOWtHTGxBY2hXWEtUNmo0UldTUjUwQnFock4zVVQ0QT09Ci0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0KLS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUNsRENDQWptZ0F3SUJBZ0lWQU9ub1JGSlRObHhMR0pvUi9FTVlMS1hjSUlCSU1Bb0dDQ3FHU000OUJBTUMKTUdneEdqQVlCZ05WQkFNTUVVbHVkR1ZzSUZOSFdDQlNiMjkwSUVOQk1Sb3dHQVlEVlFRS0RCRkpiblJsYkNCRApiM0p3YjNKaGRHbHZiakVVTUJJR0ExVUVCd3dMVTJGdWRHRWdRMnhoY21FeEN6QUpCZ05WQkFnTUFrTkJNUXN3CkNRWURWUVFHRXdKVlV6QWVGdzB4T1RFd016RXdPVFE1TWpGYUZ3MDBPVEV5TXpFeU16VTVOVGxhTUdneEdqQVkKQmdOVkJBTU1FVWx1ZEdWc0lGTkhXQ0JTYjI5MElFTkJNUm93R0FZRFZRUUtEQkZKYm5SbGJDQkRiM0p3YjNKaApkR2x2YmpFVU1CSUdBMVVFQnd3TFUyRnVkR0VnUTJ4aGNtRXhDekFKQmdOVkJBZ01Ba05CTVFzd0NRWURWUVFHCkV3SlZVekJaTUJNR0J5cUdTTTQ5QWdFR0NDcUdTTTQ5QXdFSEEwSUFCRS82RC8xV0hOcld3UG1OTUl5QktNVzUKSjZKek1zam82eFAydmtLMWNkWkdiMVBHUlAvQy84RUNnaURrbWtsbXp3THpMaSswMDBtN0xMcnRLSkEzb0MyagpnYjh3Z2J3d0h3WURWUjBqQkJnd0ZvQVU2ZWhFVWxNMlhFc1ltaEg4UXhnc3Bkd2dnRWd3VmdZRFZSMGZCRTh3ClRUQkxvRW1nUjRaRmFIUjBjSE02THk5elluZ3RZMlZ5ZEdsbWFXTmhkR1Z6TG5SeWRYTjBaV1J6WlhKMmFXTmwKY3k1cGJuUmxiQzVqYjIwdlNXNTBaV3hUUjFoU2IyOTBRMEV1WkdWeU1CMEdBMVVkRGdRV0JCVHA2RVJTVXpaYwpTeGlhRWZ4REdDeWwzQ0NBU0RBT0JnTlZIUThCQWY4RUJBTUNBUVl3RWdZRFZSMFRBUUgvQkFnd0JnRUIvd0lCCkFUQUtCZ2dxaGtqT1BRUURBZ05KQURCR0FpRUF6dzl6ZFVpVUhQTVVkMEM0bXg0MWpsRlprck0zeTVmMWxnblYKTzdGYmpPb0NJUUNvR3RVbVQ0Y1h0N1YreVNIYko4SG9iOUFhbnB2WE5IMUVSKy9nWkYrb3BRPT0KLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLQo=\",\n    \"userData\": \"\"\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "https://{{sqvs}}:{{sqvsPort}}/svs/v1/sgx_qv_verify_quote",
									"protocol": "https",
									"host": [
										"{{sqvs}}"
									],
									"port": "{{sqvsPort}}",
									"path": [
										"svs",
										"v1",
										"sgx_qv_verify_quote"
									]
								}
							},
							"status": "OK",
							"code": 200,
							"_postman_previewlanguage": "json",
							"header": [
								{
									"key": "Content-Type",
									"value": "application/json"
								},
								{
									"key": "Date",
									"value": "Fri, 12 Feb 2021 18:09:23 GMT"
								},
								{
									"key": "Content-Length",
									"value": "591"
								}
							],
							"cookie": [],
							"body": "{\n    \"Message\": \"SGX_QL_QV_RESULT_OK\",\n    \"reportData\": \"53f62c0202969dba9441905e938e3bcdfbbf6163f71446da056f437eb504320f\",\n    \"userDataMatch\": \"false\",\n    \"EnclaveIssuer\": \"cd171c56941c6ce49690b455f691d9c8a04c2e43e0a4d30f752fa5285c7ee57f\",\n    \"EnclaveMeasurement\": \"3ef4f13e42318aa5063fd740de52930488bbff8623361c686c381c44caa8793d\",\n    \"EnclaveIssuerProdID\": \"00\",\n    \"EnclaveIssuerExtProdID\": \"00000000000000000000000000000000\",\n    \"ConfigSvn\": \"00\",\n    \"IsvSvn\": \"01\",\n    \"ConfigId\": \"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\n    \"TcbLevel\": \"OutOfDate\"\n}"
						}
					]
				},
				{
					"name": "sgxVerifyQuoteAndSign",
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							},
							{
								"key": "Accept",
								"type": "text",
								"value": "application/json"
							},
							{
								"description": "Enter your bearer token in the format **Bearer &lt;token&gt;**",
								"key": "Authorization",
								"type": "text",
								"value": "Bearer {{bearerTokenKbs}}"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"quote\": \"<string>\",\n    \"userData\": \"<string>\",\n    \"nonce\": \"<string>\",\n    \"challenge\": \"<string>\"\n}"
						},
						"url": {
							"raw": "https://{{sqvs}}:{{sqvsPort}}/svs/v2/sgx_qv_verify_quote",
							"protocol": "https",
							"host": [
								"{{sqvs}}"
							],
							"port": "{{sqvsPort}}",
							"path": [
								"svs",
								"v2",
								"sgx_qv_verify_quote"
							]
						},
						"description": "Verifies the SGX ECDSA quote provided in the request body.\nQuote verifier requests SGX Quote Verification Service (SQVS) to verify quote.\nSQVS parses the quote, verifies all the parameters in the quote and returns the response.\nIt signs the quote verification response in case it is configured to do so.\n\n\nNote: KBS is not going to use this API in v3.6GA Release, it will be used in future releases."
					},
					"response": [
						{
							"name": "Success",
							"originalRequest": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"name": "Content-Type",
										"value": "application/json",
										"type": "text"
									},
									{
										"key": "Accept",
										"type": "text",
										"value": "application/json"
									},
									{
										"description": "Enter your bearer token in the format **Bearer &lt;token&gt;**",
										"key": "Authorization",
										"type": "text",
										"value": "Bearer {{bearerTokenKbs}}"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"quote\": \"AwACAAAAAAAFAAoAk5pyM/ecTKmUCg2zlX8GByMqADFimUjvNnla5ELEz5AAAAAAAgIAAQEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAADnAAAAAAAAAMEUXU9fPsSXu9VcnFDf+o0OOlDKxxXq1A9B47TK5HugAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADUEqTwfvg4kqWRX7KrWEvjHhhuWk+Vq19pUP1OuGlNewAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA2BAAAMcpaIKGq3SkXNzLrRhqjAmdIj2kNCRXwhTWgcTx+xhJew2QQHxw8AkfKwx3mloCnU6sspA8elDHqofy5AQozwcSs0GGQsADhMYYjuG0Ex3Uyylqp8MA+MJujMJfWWOhRitQe/PPdtONXpbTLPohfxB0SR7JG04DzVYXJlvVLN9dAgIAAQEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFQAAAAAAAADnAAAAAAAAAGDYWvKL6NHECgjZiwCdX4rME4Sjhc9GCADkeHkdGpecAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACMT1d115ZQPpYTf3fGioKaAFasje1wFAsIGwlEkMV7/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC+QaxkHLkZmIYLtuxD6wi2Ejwml2sYwklUVVn0ilgz2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAfCvbOVDHdLksINRQVMr2O4w2DH4EaEyaJCr3HTDLQUmyGSTENR6VBAnJAHXNTuxsIEfCP8jM0RPeD2gtIABhcyAAAAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8FAHAOAAAtLS0tLUJFR0lOIENFUlRJRklDQVRFLS0tLS0KTUlJRTlqQ0NCSnVnQXdJQkFnSVZBTW5hTlU0VXNxc0xQNFQ4MXhHNVY4d0xCVlJ6TUFvR0NDcUdTTTQ5QkFNQ01IQXhJakFnQmdOVgpCQU1NR1VsdWRHVnNJRk5IV0NCUVEwc2dVR3hoZEdadmNtMGdRMEV4R2pBWUJnTlZCQW9NRVVsdWRHVnNJRU52Y25CdmNtRjBhVzl1Ck1SUXdFZ1lEVlFRSERBdFRZVzUwWVNCRGJHRnlZVEVMTUFrR0ExVUVDQXdDUTBFeEN6QUpCZ05WQkFZVEFsVlRNQjRYRFRJd01USXgKTmpBNE1EY3lNMW9YRFRJM01USXhOakE0TURjeU0xb3djREVpTUNBR0ExVUVBd3daU1c1MFpXd2dVMGRZSUZCRFN5QkRaWEowYVdacApZMkYwWlRFYU1CZ0dBMVVFQ2d3UlNXNTBaV3dnUTI5eWNHOXlZWFJwYjI0eEZEQVNCZ05WQkFjTUMxTmhiblJoSUVOc1lYSmhNUXN3CkNRWURWUVFJREFKRFFURUxNQWtHQTFVRUJoTUNWVk13V1RBVEJnY3Foa2pPUFFJQkJnZ3Foa2pPUFFNQkJ3TkNBQVNnR3pJL2o5VXEKYk9hRGJnSHF2V0J3ZW80ZEhPS0M4dmRBMWh3d3BpU2hhbVJqbU9ObDdYUGtLeGptT1h1NXlHb3U5S1J5cExTVSs1RURvQm4xbm9QVwpvNElERURDQ0F3d3dId1lEVlIwakJCZ3dGb0FVV1NQVHAwcW9ZMVF1T1hDdDRBOEhLMWNrS3Jjd2J3WURWUjBmQkdnd1pqQmtvR0tnCllJWmVhSFIwY0hNNkx5OXpZbmd1WVhCcExuUnlkWE4wWldSelpYSjJhV05sY3k1cGJuUmxiQzVqYjIwdmMyZDRMMk5sY25ScFptbGoKWVhScGIyNHZkak12Y0dOclkzSnNQMk5oUFhCc1lYUm1iM0p0Sm1WdVkyOWthVzVuUFdSbGNqQWRCZ05WSFE0RUZnUVVlTkVoWXoycQplays1SjdwY3oxMjNDNHV4MzRjd0RnWURWUjBQQVFIL0JBUURBZ2JBTUF3R0ExVWRFd0VCL3dRQ01BQXdnZ0k1QmdrcWhraUcrRTBCCkRRRUVnZ0lxTUlJQ0pqQWVCZ29xaGtpRytFMEJEUUVCQkJBY2RIcXJkZ0tIQlVWRUZvajVnancrTUlJQll3WUtLb1pJaHZoTkFRMEIKQWpDQ0FWTXdFQVlMS29aSWh2aE5BUTBCQWdFQ0FRSXdFQVlMS29aSWh2aE5BUTBCQWdJQ0FRSXdFQVlMS29aSWh2aE5BUTBCQWdNQwpBUUF3RUFZTEtvWklodmhOQVEwQkFnUUNBUUF3RUFZTEtvWklodmhOQVEwQkFnVUNBUUF3RUFZTEtvWklodmhOQVEwQkFnWUNBUUF3CkVBWUxLb1pJaHZoTkFRMEJBZ2NDQVFBd0VBWUxLb1pJaHZoTkFRMEJBZ2dDQVFBd0VBWUxLb1pJaHZoTkFRMEJBZ2tDQVFBd0VBWUwKS29aSWh2aE5BUTBCQWdvQ0FRQXdFQVlMS29aSWh2aE5BUTBCQWdzQ0FRQXdFQVlMS29aSWh2aE5BUTBCQWd3Q0FRQXdFQVlMS29aSQpodmhOQVEwQkFnMENBUUF3RUFZTEtvWklodmhOQVEwQkFnNENBUUF3RUFZTEtvWklodmhOQVEwQkFnOENBUUF3RUFZTEtvWklodmhOCkFRMEJBaEFDQVFBd0VBWUxLb1pJaHZoTkFRMEJBaEVDQVFvd0h3WUxLb1pJaHZoTkFRMEJBaElFRUFJQ0FBQUFBQUFBQUFBQUFBQUEKQUFBd0VBWUtLb1pJaHZoTkFRMEJBd1FDQUFBd0ZBWUtLb1pJaHZoTkFRMEJCQVFHSUdCcUFBQUFNQThHQ2lxR1NJYjRUUUVOQVFVSwpBUUV3SGdZS0tvWklodmhOQVEwQkJnUVFrZkNIaG5mR3pranVDZ1AyaG1Mem16QkVCZ29xaGtpRytFMEJEUUVITURZd0VBWUxLb1pJCmh2aE5BUTBCQndFQkFmOHdFQVlMS29aSWh2aE5BUTBCQndJQkFRQXdFQVlMS29aSWh2aE5BUTBCQndNQkFmOHdDZ1lJS29aSXpqMEUKQXdJRFNRQXdSZ0loQUtMRWxXVEMwRzd2cmM5cGhvR01BWWRMSFl5N244YksxMjZWTWw5TG9CUmZBaUVBbWNUMXRvNWpHNVBSSW5hMApTZUZVdlIrVXFHVG5LaSthM2lkVTYraEFRL0U9Ci0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0tLS0tLUJFR0lOIENFUlRJRklDQVRFLS0tLS0KTUlJQ21qQ0NBa0NnQXdJQkFnSVVXU1BUcDBxb1kxUXVPWEN0NEE4SEsxY2tLcmN3Q2dZSUtvWkl6ajBFQXdJdwphREVhTUJnR0ExVUVBd3dSU1c1MFpXd2dVMGRZSUZKdmIzUWdRMEV4R2pBWUJnTlZCQW9NRVVsdWRHVnNJRU52CmNuQnZjbUYwYVc5dU1SUXdFZ1lEVlFRSERBdFRZVzUwWVNCRGJHRnlZVEVMTUFrR0ExVUVDQXdDUTBFeEN6QUoKQmdOVkJBWVRBbFZUTUI0WERURTVNVEF6TVRFeU16TTBOMW9YRFRNME1UQXpNVEV5TXpNME4xb3djREVpTUNBRwpBMVVFQXd3WlNXNTBaV3dnVTBkWUlGQkRTeUJRYkdGMFptOXliU0JEUVRFYU1CZ0dBMVVFQ2d3UlNXNTBaV3dnClEyOXljRzl5WVhScGIyNHhGREFTQmdOVkJBY01DMU5oYm5SaElFTnNZWEpoTVFzd0NRWURWUVFJREFKRFFURUwKTUFrR0ExVUVCaE1DVlZNd1dUQVRCZ2NxaGtqT1BRSUJCZ2dxaGtqT1BRTUJCd05DQUFRd3ArTGMrVFVCdGcxSAorVThKSXNNc2JqSGpDa1R0WGI4alBNNnIyZGh1OXpJYmxoRFo3SU5mcXQzSXg4WGNGS0Q4azBORVhya1o2NnFKClhhMUt6TElLbzRHL01JRzhNQjhHQTFVZEl3UVlNQmFBRk9ub1JGSlRObHhMR0pvUi9FTVlMS1hjSUlCSU1GWUcKQTFVZEh3UlBNRTB3UzZCSm9FZUdSV2gwZEhCek9pOHZjMko0TFdObGNuUnBabWxqWVhSbGN5NTBjblZ6ZEdWawpjMlZ5ZG1salpYTXVhVzUwWld3dVkyOXRMMGx1ZEdWc1UwZFlVbTl2ZEVOQkxtUmxjakFkQmdOVkhRNEVGZ1FVCldTUFRwMHFvWTFRdU9YQ3Q0QThISzFja0tyY3dEZ1lEVlIwUEFRSC9CQVFEQWdFR01CSUdBMVVkRXdFQi93UUkKTUFZQkFmOENBUUF3Q2dZSUtvWkl6ajBFQXdJRFNBQXdSUUloQUoxcStGVHorZ1V1VmZCUXVDZ0pzRnJMMlRUUwplMWFCWjUzTzUyVGpGaWU2QWlBcmlQYVJhaFVYOU9hOWtHTGxBY2hXWEtUNmo0UldTUjUwQnFock4zVVQ0QT09Ci0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0KLS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUNsRENDQWptZ0F3SUJBZ0lWQU9ub1JGSlRObHhMR0pvUi9FTVlMS1hjSUlCSU1Bb0dDQ3FHU000OUJBTUMKTUdneEdqQVlCZ05WQkFNTUVVbHVkR1ZzSUZOSFdDQlNiMjkwSUVOQk1Sb3dHQVlEVlFRS0RCRkpiblJsYkNCRApiM0p3YjNKaGRHbHZiakVVTUJJR0ExVUVCd3dMVTJGdWRHRWdRMnhoY21FeEN6QUpCZ05WQkFnTUFrTkJNUXN3CkNRWURWUVFHRXdKVlV6QWVGdzB4T1RFd016RXdPVFE1TWpGYUZ3MDBPVEV5TXpFeU16VTVOVGxhTUdneEdqQVkKQmdOVkJBTU1FVWx1ZEdWc0lGTkhXQ0JTYjI5MElFTkJNUm93R0FZRFZRUUtEQkZKYm5SbGJDQkRiM0p3YjNKaApkR2x2YmpFVU1CSUdBMVVFQnd3TFUyRnVkR0VnUTJ4aGNtRXhDekFKQmdOVkJBZ01Ba05CTVFzd0NRWURWUVFHCkV3SlZVekJaTUJNR0J5cUdTTTQ5QWdFR0NDcUdTTTQ5QXdFSEEwSUFCRS82RC8xV0hOcld3UG1OTUl5QktNVzUKSjZKek1zam82eFAydmtLMWNkWkdiMVBHUlAvQy84RUNnaURrbWtsbXp3THpMaSswMDBtN0xMcnRLSkEzb0MyagpnYjh3Z2J3d0h3WURWUjBqQkJnd0ZvQVU2ZWhFVWxNMlhFc1ltaEg4UXhnc3Bkd2dnRWd3VmdZRFZSMGZCRTh3ClRUQkxvRW1nUjRaRmFIUjBjSE02THk5elluZ3RZMlZ5ZEdsbWFXTmhkR1Z6TG5SeWRYTjBaV1J6WlhKMmFXTmwKY3k1cGJuUmxiQzVqYjIwdlNXNTBaV3hUUjFoU2IyOTBRMEV1WkdWeU1CMEdBMVVkRGdRV0JCVHA2RVJTVXpaYwpTeGlhRWZ4REdDeWwzQ0NBU0RBT0JnTlZIUThCQWY4RUJBTUNBUVl3RWdZRFZSMFRBUUgvQkFnd0JnRUIvd0lCCkFUQUtCZ2dxaGtqT1BRUURBZ05KQURCR0FpRUF6dzl6ZFVpVUhQTVVkMEM0bXg0MWpsRlprck0zeTVmMWxnblYKTzdGYmpPb0NJUUNvR3RVbVQ0Y1h0N1YreVNIYko4SG9iOUFhbnB2WE5IMUVSKy9nWkYrb3BRPT0KLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLQo=\",\n    \"userData\": \"\",\n    \"challenge\": \"abcd\"\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "https://{{sqvs}}:{{sqvsPort}}/svs/v2/sgx_qv_verify_quote",
									"protocol": "https",
									"host": [
										"{{sqvs}}"
									],
									"port": "{{sqvsPort}}",
									"path": [
										"svs",
										"v2",
										"sgx_qv_verify_quote"
									]
								}
							},
							"status": "OK",
							"code": 200,
							"_postman_previewlanguage": "json",
							"header": [
								{
									"key": "Content-Type",
									"value": "application/json"
								},
								{
									"key": "Date",
									"value": "Fri, 30 Apr 2021 10:39:52 GMT"
								},
								{
									"key": "Transfer-Encoding",
									"value": "chunked"
								}
							],
							"cookie": [],
							"body": "{\n    \"quoteData\":\"<Base 64 encoded JSON>\",\n    \"signature\": \"<Digital Signature of the content of response field>\",\n    \"certificateChain\": \"<Chain of leaf and intermediate certs>\"\n}"
						}
					]
				}
			],
			"description": "1. Nginx will initiate a Key Transfer with the new Key id by calling Key Broker Service (KBS) REST endpoint (GET /v1/keys/:keyId/dhsm2-transfer) and will get a 401 HTTP response from KBS since the session is not established. \n2. Nginx will create a new session key by calling the KBS REST endpoint (POST /v1/session).\n3. SKC Client will send the SGX Quote to KBS, then KBS will verify the quote by calling SGX Quote Verification Service(SQVS) REST endpoint (POST /v1/sgx_qv_verify_quote).\n4. SQVS checks whether the quote signature and PCK Certificate are valid checks other parameters in the quote and returns the verification result. SQVS contacts SGX Caching service (SCS) to make sure that PCKCRL, TCBInfo, and QEIdentity in the quote are correct. \n5. Once the session is successfully established, Again Nginx will initiate a Key Transfer with the key id by calling KBS REST endpoint (GET /v1/keys/:keyId/dhsm2-transfer) and will get the response as key transfer successful.\n\nOn SGX Compute node, Execute below commands for KBS key-transfer:\n\n\nNote: Before initiating key transfer make sure, PYKMIP server is running.\n\n```\n    pkill nginx\n```\n\nRemove any existing pkcs11 token\n\n```\n    rm -rf /opt/intel/cryptoapitoolkit/tokens/*\n```\n\nInitiate Key transfer from KBS\n\n```\n    systemctl restart nginx\n```\n\nChanging group ownership and permissions of pkcs11 token\n\n```\n    chown -R root:intel /opt/intel/cryptoapitoolkit/tokens/\n```\n\n```\n    chmod -R 770 /opt/intel/cryptoapitoolkit/tokens/\n```\n\nEstablish a tls session with the nginx using the key transferred inside the enclave\n\n```\n    wget https://localhost:2443 --no-check-certificate\n```",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				}
			]
		}
	],
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		}
	]
}